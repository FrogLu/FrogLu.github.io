(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{175:function(t,e,n){"use strict";n.r(e);var r=n(0),s=Object(r.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),n("p",[t._v("对于返回值为对象(为讨论方便，此处所述对象亦包括通常变量所指的内置类型)的函数：")]),t._v(" "),t._m(2),n("p",[t._v("以及诸如：")]),t._v(" "),t._m(3),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),n("p",[t._v("为了解决这一问题，C++11一方面引入了移动语义(move semantics)，另一方面将在C++11之前已经被许多主流编译器所采用的copy elision纳入了标准中。")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),n("p",[t._v("为了支持移动语义，C++11提出了右值引用(rvalue reference)以及移动构造(move constructor)函数和移动赋值运算符的概念。")]),t._v(" "),n("p",[t._v("右值引用用&&来表示，用以表示即将销毁、不再使用的临时对象。而在类定义中的移动构造函数和移动赋值运算符的参数规定为右值引用，简单实现如下：")]),t._v(" "),t._m(10),n("p",[t._v("即可以理解成通过将右值引用来“标记”临时对象，触发移动语义，使得在函数返回值或使用赋值运算符时，调用移动构造函数或移动赋值运算符，而不是调用拷贝构造运算符或拷贝赋值运算符，从而避免由于传值拷贝造成的不必要开销，提高性能。")]),t._v(" "),n("p",[t._v("但在实际编程实践中，往往存在尽管一个对象是一个左值，但我们程序员希望对其像右值一样进行移动操作来避免拷贝操作所带来的开销，但通常我们不能直接将一个右值引用绑定到一个左值上：")]),t._v(" "),t._m(11),n("p",[t._v("为解决这一问题，C++11引入了std::move来将左值转换（cast）右值。")]),t._v(" "),t._m(12),t._v(" "),n("p",[t._v("std::move的工作基础是C++对于右值引用的模板实参推断进行了如下规定：")]),t._v(" "),n("p",[t._v("考虑如下模板函数：")]),t._v(" "),t._m(13),n("p",[t._v("通常按照我们不能直接将一个右值引用绑定到一个左值上的原则，假定i是一个int对象，那么显然有：")]),t._v(" "),t._m(14),n("p",[t._v("但是，C++定义了两条例外规则：")]),t._v(" "),n("p",[t._v("首先，将左值传递给函数的右值引用参数时，编译器推断模板类型参数T为其左值引用类型。对于func(i)，T为int&。")]),t._v(" "),n("p",[t._v("在这种情况下，定义了引用折叠：")]),t._v(" "),t._m(15),t._v(" "),n("p",[t._v("这也就使得我们可以将任意类型的实参传递给T&&类型的函数参数。")]),t._v(" "),t._m(16),t._v(" "),n("p",[t._v("C++标准库中的std::move模板定义如下：")]),t._v(" "),t._m(17),n("p",[t._v("其中std::remove_reference<_Ty>::type 为类型_Ty的非引用类型。")]),t._v(" "),n("p",[t._v("理解std::move最重要的是清楚std::move的作用并不是实现移动操作本身，而是实现一种cast，将左值转换成右值，有点类似于将变量Arg打上一个右值标记，强行触发移动语义，从而使得对象调用移动构造函数或移动赋值运算符，实际的移动操作仍需要在对象所属类的移动构造函数和移动赋值运算符中进行定义，这相当于告诉编译器这个对象作为赋值源对象时是可以丢弃的右值：")]),t._v(" "),t._m(18),t._m(19),t._v(" "),t._m(20),t._v(" "),n("p",[t._v("std::forwarding的C++11标准库实现如下：")]),t._v(" "),t._m(21),n("p",[t._v("可以看出与std::move不同的是，std::forward必须通过显式模板实参来调用，且std::forward<_Ty>返回类型是_Ty&&。")]),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),n("p",[t._v("copy elision直译为复制省略。来自于(named) return value optimization (返回值优化，(N)ROV)，是一种编译器用于优化函数返回值，避免拷贝开销的技术。C++98/03标准中并没有要求编译器提供这一技术，但当时主流的编译器如GCC，clang等都提供了这一技术，C++11将这一技术写入了标准，并将其称为copy elision。")]),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),n("p",[t._v("并给出了一个例子：")]),t._v(" "),t._m(27),n("p",[t._v("还给出了解释：")]),t._v(" "),t._m(28),t._m(29),t._v(" "),t._m(30),n("p",[t._v("这对应第32小点中的第一种情况return statement，然后是函数体执行结束，得到返回值：")]),t._v(" "),t._m(31),n("p",[t._v("这对应于第三种情况没有绑定引用的临时变量。")]),t._v(" "),n("p",[t._v("为了更好的了解这一行为，在类成员函数中加入输出语句：")]),t._v(" "),t._m(32),n("p",[t._v("其输出为（#为注释符，其后为注释而非输出）：")]),t._v(" "),t._m(33),t._m(34),t._v(" "),t._m(35),n("p",[t._v("其输出为：")]),t._v(" "),t._m(36),n("p",[t._v("由于加入了if-else分支，并不属于第32小点中所描述的四种情况，因此在函数返回值的赋值过程中并没有执行优化。")]),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++11 draft N3242 section 12.8(32)"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics",target:"_blank",rel:"noopener noreferrer"}},[t._v("A Brief Introduction to Rvalue References"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://stackoverflow.com/questions/3413470/what-is-stdmove-and-when-should-it-be-used",target:"_blank",rel:"noopener noreferrer"}},[t._v("What is std::move(), and when should it be used?"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://en.wikipedia.org/wiki/C%2B%2B11#Rvalue_references_and_move_constructors",target:"_blank",rel:"noopener noreferrer"}},[t._v("Rvalue references and move constructors"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Copy_elision",target:"_blank",rel:"noopener noreferrer"}},[t._v("Copy elision"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://en.cppreference.com/w/cpp/language/copy_elision",target:"_blank",rel:"noopener noreferrer"}},[t._v("Copy elision"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://www.zhihu.com/question/50652989",target:"_blank",rel:"noopener noreferrer"}},[t._v("关于C++右值及std::move()的疑问？"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en",target:"_blank",rel:"noopener noreferrer"}},[t._v("RVO V.S. std::move"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://stackoverflow.com/questions/2131904/trusting-the-return-value-optimization",target:"_blank",rel:"noopener noreferrer"}},[t._v("Trusting the Return Value Optimization"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)?redirectedfrom=MSDN#nrvo_cpp05_topic3",target:"_blank",rel:"noopener noreferrer"}},[t._v("Named Return Value Optimization in Visual C++ 2005"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://stackoverflow.com/questions/15413037/what-does-cv-unqualified-mean-in-c",target:"_blank",rel:"noopener noreferrer"}},[t._v("What does “cv-unqualified” mean in C++?"),n("OutboundLink")],1)]),t._v(" "),n("li",[t._v("C++ primer 5th")]),t._v(" "),n("li",[t._v("Effective C++ 3th")])])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"浅谈move-semantics及copy-elision的一点理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浅谈move-semantics及copy-elision的一点理解","aria-hidden":"true"}},[this._v("#")]),this._v(" 浅谈move semantics及copy elision的一点理解")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"背景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#背景","aria-hidden":"true"}},[this._v("#")]),this._v(" 背景")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Object foo(){\n    Object obj;\n\n    return obj;\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Object obj1;\nObject obj2=obj1;   //  assume class Object have defined\n                    //  copy constructor and operator=\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这样的传值(pass-by-value)操作会形成拷贝，从而调用构造函数和析构函数，产生开销，"),e("br"),this._v("\n特别地，当Object类是深度定义的很复杂的类时，这将会是不小的开销，从而影响性能。但在C++11"),e("br"),this._v("\n发布之前，C++标准并没有提供一种很好的解决方案。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("因为尽管比如返回值为函数局部对象(或对象)的引用或指针的函数，看似避免了返回值的拷贝，"),e("br"),this._v("\n但这样的行为会给整个程序带来致命隐患，而且这一隐患往往是隐式存在的，难以被察觉和解决的。"),e("br"),this._v("\n因为函数内的局部对象在函数执行结束返回以后会被销毁，那么返回这个局部对象的引用或指针将会"),e("br"),this._v("\n是悬垂的，使用这样的引用或指针访问内存块的行为将会是未定义的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("其他如在stack空间(通过new动态分配内存)或heap空间(静态局部对象)等方式尽管避免了拷贝开销，"),e("br"),this._v("\n但都带来了更大安全隐患。Scott Meyers的《Effective C++ 3th》中的item21对以上行为做了详细的解释。顺便提一下，item4提供了一种单线程环境的解决方案，但在多线程环境下仍存在安全隐患。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决方案","aria-hidden":"true"}},[this._v("#")]),this._v(" 解决方案")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"move-semantics"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#move-semantics","aria-hidden":"true"}},[this._v("#")]),this._v(" move semantics")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"右值引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#右值引用","aria-hidden":"true"}},[this._v("#")]),this._v(" 右值引用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class Object{\n    Object(Object&& src){\n        // 为方便起见并未考虑自赋值等其他情形\n        data = src.data;    // data往往为指向对象的指针，避免拷贝\n        src.data = nullptr; // “销毁”源对象(src)\n    }\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("int &&rr1 = 42;     //  正确： 字面常量是右值\nint &&rr2 = rr1;    //  错误： 表达式rr1是左值\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"std-move工作基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#std-move工作基础","aria-hidden":"true"}},[this._v("#")]),this._v(" std::move工作基础")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("template <typename T> void func(T&&);\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("func(42);   //  实参是一个int类型的右值；模板参数T是int\nfunc(i);    //  调用不合法，i是左值\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("X& &、X&& &和X&& &都折叠成类型X &")]),this._v(" "),e("li",[this._v("类型X&& &&折叠成X&&")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"std-move"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#std-move","aria-hidden":"true"}},[this._v("#")]),this._v(" std::move")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("template <class _Ty>\ntypename remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {\n    return static_cast<remove_reference_t<_Ty>&&>(_Arg);\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('std::string str("move");\nstd::string&& rr1 = std::move(str);     //  单纯的绑定引用，未触发移动构造，\n                                        //  str内元素未被移动\nstd::string rr2 = std::move(str);       //  触发移动构造，str内元素被移动\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"pefect-forwarding"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pefect-forwarding","aria-hidden":"true"}},[this._v("#")]),this._v(" pefect forwarding")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("pefect forwarding的译名有完美转发，精确转发等，表示将实参联通类型不变地进行转发的行为。"),e("br"),this._v("\nC++11提供了std::forward用于实现pefect forwarding。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("template <class _Ty>\n_Ty&& forward( remove_reference_t<_Ty>& _Arg ) noexcept {\n    return static_cast<_Ty&&>(_Arg);\n}\ntemplate <class _Ty>\n_Ty&& forward( remove_reference_t<_Ty>&& _Arg ) noexcept {\n    return static_cast<_Ty&&>(_Arg);\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("因为如果_Ty是左值Type&，则根据引用折叠，_Ty&&将折叠成Type&，则forward将返回Type&，"),e("br"),this._v("\n反之如果为右值Type&，_Ty&&将折叠成Type&&，则forward将返回Type&&。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"copy-elision"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#copy-elision","aria-hidden":"true"}},[this._v("#")]),this._v(" copy elision")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#细节","aria-hidden":"true"}},[this._v("#")]),this._v(" 细节")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("C++11 draft N3225在section12.8的第32小点中是这么描述的："),e("br"),this._v("\n（P.S. C++11标准的正式稿是N3242，但是太贵了。。不过N3225这份草稿基本是与C++11正式稿一致的。）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("32 When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\nobject, even if the copy/move constructor and/or destructor for the object have side effects. In such cases,\nthe implementation treats the source and target of the omitted copy/move operation as simply two different\nways of referring to the same object, and the destruction of that object occurs at the later of the times\nwhen the two objects would have been destroyed without the optimization.123 This elision of copy/move\noperations, called copy elision, is permitted in the following circumstances (which may be combined to\neliminate multiple copies):\n— in a return statement in a function with a class return type, when the expression is the name of a\nnon-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified type as the function return type, the copy/move operation can be omitted by constructing\nthe automatic object directly into the function’s return value\n— in a throw-expression, when the operand is the name of a non-volatile automatic object (other than\na function or catch-clause parameter) whose scope does not extend beyond the end of the innermost\nenclosing try-block (if there is one), the copy/move operation from the operand to the exception\nobject (15.1) can be omitted by constructing the automatic object directly into the exception object\n— when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\nto a class object with the same cv-unqualified type, the copy/move operation can be omitted by\nconstructing the temporary object directly into the target of the omitted copy/move\n— when the exception-declaration of an exception handler (Clause 15) declares an object of the same type\n(except for cv-qualification) as the exception object (15.1), the copy/move operation can be omitted\nby treating the exception-declaration as an alias for the exception object if the meaning of the program\nwill be unchanged except for the execution of constructors and destructors for the object declared by\nthe exception-declaration.\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class Thing {\npublic:\n  Thing();\n  ~Thing();\n  Thing(const Thing&);\n};\nThing f() {\n  Thing t;\n  return t;\n}\n\nThing t2 = f();\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Here the criteria for elision can be combined to eliminate two calls to the copy constructor of class Thing:\nthe copying of the local automatic object t into the temporary object for the return value of function f()\nand the copying of that temporary object into object t2. Effectively, the construction of the local object\nt can be viewed as directly initializing the global object t2, and that object’s destruction will occur at\nprogram exit. Adding a move constructor to Thing has the same effect, but it is the move construction from\nthe temporary object to t2 that is elided. — end example ]\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("也就是说对于语句"),e("code",[this._v("Thing t2 = f();")]),this._v("存在两个可以优化的拷贝操作，首先是"),e("code",[this._v("f()")]),this._v("函数调用返回语句时有：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Thing temp_t = t;\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Thing t2 = temp_t;\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('class Thing {\npublic:\n  Thing(){\n      std::cout << "constructor." << std::endl;\n  }\n  ~Thing(){\n      std::cout << "destructor." << std::endl;\n  }\n  Thing(const Thing&){\n      std::cout << "copy constructor." << std::endl;\n  }\n};\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("constructor.    # t2.constructor\ndestructor.     # main() ends, t2.destrctor\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("而在"),e("code",[this._v("f()")]),this._v("函数中加入if-else分支后：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Thing f(int n) {\n  Thing t, t1;\n  if(n > 10){\n      return t;\n  }\n  else{\n      return t1;\n  }\n}\n\nThing t2 = f(1);\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("constructor.    # t and t1\nconstructor.    # constructor\ncopy constructor.   # temp_t = t or t1, ' t2 = temp_t ' is optimized\ndestructor.     # t and t1\ndestructor.     # destructor\ndestructor.     # main() ends, t2.destructor\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"与std-move的比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与std-move的比较","aria-hidden":"true"}},[this._v("#")]),this._v(" 与std::move的比较")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("可以看出，在满足第一种情况下的函数中，"),e("code",[this._v("copy elision")]),this._v("能够提供更好的优化能力，出于安全考虑并不能返回Type&&，即函数返回语句不能为"),e("code",[this._v("return std::move(obj);")]),this._v("，因为这会带来安全隐患，得不偿失。但std::move可以辅助程序员在编译器无法优化的地方进行优化。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"reference"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reference","aria-hidden":"true"}},[this._v("#")]),this._v(" reference")])}],!1,null,null,null);e.default=s.exports}}]);